<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
    <meta charset="UTF-8">
    <title>PDF Editor</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="/static/style.css">
    <style>
        html, body, * {
            color-rendering: auto;
            forced-color-adjust: none;
        }
    </style>
</head>
<body>
    <main class="container">
        <h1>Reorder and Delete Pages</h1>
        <div id="drop-zone" class="drop-zone">
            <p>Drop your PDF here or click to browse</p>
            <div id="upload-waitbar" class="waitbar hidden">
                <div class="waitbar-fill"></div>
            </div>
            <span id="upload-status" class="waitbar-status hidden">Uploading...</span>
            <div id="processing-waitbar" class="waitbar hidden">
                <div class="waitbar-fill"></div>
            </div>
            <span id="processing-status" class="waitbar-status hidden">Processing...</span>
            <div id="download-waitbar" class="waitbar hidden">
                <div class="waitbar-fill"></div>
            </div>
            <span id="download-status" class="waitbar-status hidden">Downloading...</span>
            <input type="file" id="pdf-upload" accept="application/pdf" name="pdf">
            <button id="browse-btn" title="Browse Files">
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="17 8 12 3 7 8"></polyline>
                    <line x1="12" y1="3" x2="12" y2="15"></line>
                </svg>
            </button>
        </div>
        <div class="button-group">
            <button id="theme-toggle" title="Toggle Dark Mode">
                <svg id="theme-icon" xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="12" cy="12" r="5"></circle>
                    <line x1="12" y1="1" x2="12" y2="3"></line>
                    <line x1="12" y1="21" x2="12" y2="23"></line>
                    <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                    <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                    <line x1="1" y1="12" x2="3" y2="12"></line>
                    <line x1="21" y1="12" x2="23" y2="12"></line>
                    <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                    <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                </svg>
            </button>
            <button id="clear-btn" title="Clear PDF">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 6h18"></path>
                    <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                    <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                    <line x1="10" x2="10" y1="11" y2="17"></line>
                    <line x1="14" x2="14" y1="11" y2="17"></line>
                </svg>
            </button>
            <button id="download-btn" class="hidden" title="Save and Download">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path>
                    <polyline points="7 10 12 15 17 10"></polyline>
                    <line x1="12" y1="15" x2="12" y2="3"></line>
                </svg>
            </button>
        </div>
        <div id="zoom-control" class="zoom-control hidden">
            <button id="zoom-icon" title="Zoom">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <circle cx="11" cy="11" r="8"></circle>
                    <line x1="21" y1="21" x2="16.65" y2="16.65"></line>
                    <line x1="11" y1="8" x2="11" y2="14"></line>
                    <line x1="8" y1="11" x2="14" y2="11"></line>
                </svg>
            </button>
            <input type="range" id="zoom-slider" min="100" max="200" value="100">
        </div>
        <div id="state-debug"></div>
        <div id="page-grid" class="page-grid"></div>
    </main>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <script>
        let pageOrder = [];
        let pagesToDelete = [];
        let originalFile = null;
        let previews = [];
        let zoomLevel = 100;

        // Ensure all waitbars and status texts are hidden on load
        document.getElementById('upload-waitbar').classList.add('hidden');
        document.getElementById('processing-waitbar').classList.add('hidden');
        document.getElementById('download-waitbar').classList.add('hidden');
        document.getElementById('upload-status').classList.add('hidden');
        document.getElementById('processing-status').classList.add('hidden');
        document.getElementById('download-status').classList.add('hidden');

        // Theme Toggle
        const themeToggle = document.getElementById('theme-toggle');
        const themeIcon = document.getElementById('theme-icon');
        const setTheme = (theme) => {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            themeIcon.innerHTML = theme === 'dark' ?
                `<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>` :
                `<circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>`;
            console.log(`Applied theme: ${theme}`);
        };
        const savedTheme = localStorage.getItem('theme') || 'light';
        setTheme(savedTheme);

        themeToggle.addEventListener('click', () => {
            const currentTheme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            setTheme(currentTheme);
        });

        // Drag-and-Drop Uploader
        const dropZone = document.getElementById('drop-zone');
        const fileInput = document.getElementById('pdf-upload');
        const browseBtn = document.getElementById('browse-btn');
        const uploadWaitbar = document.getElementById('upload-waitbar');
        const uploadFill = document.querySelector('#upload-waitbar .waitbar-fill');
        const uploadStatus = document.getElementById('upload-status');
        const processingWaitbar = document.getElementById('processing-waitbar');
        const processingFill = document.querySelector('#processing-waitbar .waitbar-fill');
        const processingStatus = document.getElementById('processing-status');
        const downloadWaitbar = document.getElementById('download-waitbar');
        const downloadFill = document.querySelector('#download-waitbar .waitbar-fill');
        const downloadStatus = document.getElementById('download-status');
        const zoomSlider = document.getElementById('zoom-slider');
        const zoomControl = document.getElementById('zoom-control');

        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.classList.add('active');
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.classList.remove('active');
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('active');
            const file = e.dataTransfer.files[0];
            if (file && file.type === 'application/pdf') {
                fileInput.files = e.dataTransfer.files;
                handleUpload(file);
            }
        });
        browseBtn.addEventListener('click', () => fileInput.click());

        fileInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) handleUpload(file);
        });

        async function handleUpload(file) {
            console.time('upload');
            originalFile = file;
            // Reset all waitbars and status texts
            uploadWaitbar.classList.add('hidden');
            processingWaitbar.classList.add('hidden');
            downloadWaitbar.classList.add('hidden');
            uploadFill.style.width = '0%';
            processingFill.style.width = '0%';
            downloadFill.style.width = '0%';
            uploadStatus.classList.add('hidden');
            processingStatus.classList.add('hidden');
            downloadStatus.classList.add('hidden');
            // Show upload waitbar and status
            requestAnimationFrame(() => {
                uploadWaitbar.classList.remove('hidden');
                uploadStatus.classList.remove('hidden');
                uploadStatus.textContent = 'Uploading...';
                uploadFill.classList.add('active');
            });
            // Simulate upload progress
            let uploadProgress = 0;
            const uploadInterval = setInterval(() => {
                uploadProgress = Math.min(uploadProgress + 10, 100);
                uploadFill.style.width = `${uploadProgress}%`;
            }, 200);
            const formData = new FormData();
            formData.append('pdf', file);
            try {
                const response = await fetch('/upload', {
                    method: 'POST',
                    body: formData,
                    credentials: 'include' // Ensure cookies are sent
                });
                clearInterval(uploadInterval);
                uploadFill.style.width = '100%';
                uploadWaitbar.classList.add('hidden');
                uploadFill.classList.remove('active');
                uploadStatus.classList.add('hidden');
                const data = await response.json();
                if (data.error) {
                    console.error('Upload failed:', data.error);
                    alert('Error uploading PDF: ' + data.error);
                    console.timeEnd('upload');
                    return;
                }
                const sessionId = data.session_id;
                previews = data.images || [];
                pageOrder = Array.from({ length: data.total_pages }, (_, i) => i);
                pagesToDelete = [];
                console.log(`Upload successful: Session ID ${sessionId}, Pages: ${data.total_pages}, Images: ${previews.length}`);
                console.timeEnd('upload');
                // Progressive rendering
                renderPages(data.total_pages);
                document.getElementById('download-btn').classList.remove('hidden');
                zoomControl.classList.remove('hidden');
            } catch (error) {
                console.error('Upload error:', error);
                alert('Error uploading PDF: ' + error.message);
                clearInterval(uploadInterval);
                uploadWaitbar.classList.add('hidden');
                uploadFill.classList.remove('active');
                uploadStatus.classList.add('hidden');
                console.timeEnd('upload');
            }
        }

        function updateDebugState() {
            document.getElementById('state-debug').innerHTML = `
                <p>Current state - Page Order: ${JSON.stringify(pageOrder)}, Pages to Delete: ${JSON.stringify(pagesToDelete)}</p>
            `;
        }

        document.getElementById('clear-btn').addEventListener('click', async () => {
            await fetch('/clear', { method: 'POST' });
            pageOrder = [];
            pagesToDelete = [];
            previews = [];
            originalFile = null;
            zoomLevel = 100;
            zoomSlider.value = 100;
            document.getElementById('page-grid').innerHTML = '';
            document.getElementById('state-debug').innerHTML = '';
            document.getElementById('download-btn').classList.add('hidden');
            zoomControl.classList.add('hidden');
            document.getElementById('pdf-upload').value = '';
            uploadWaitbar.classList.add('hidden');
            processingWaitbar.classList.add('hidden');
            downloadWaitbar.classList.add('hidden');
            uploadFill.style.width = '0%';
            processingFill.style.width = '0%';
            downloadFill.style.width = '0%';
            uploadStatus.classList.add('hidden');
            processingStatus.classList.add('hidden');
            downloadStatus.classList.add('hidden');
            console.log('Cleared state');
        });

        document.getElementById('download-btn').addEventListener('click', async () => {
            console.log('Before download:', { pageOrder, pagesToDelete });
            uploadWaitbar.classList.add('hidden');
            processingWaitbar.classList.add('hidden');
            downloadWaitbar.classList.remove('hidden');
            uploadStatus.classList.add('hidden');
            processingStatus.classList.add('hidden');
            downloadStatus.classList.remove('hidden');
            downloadStatus.textContent = 'Downloading...';
            downloadFill.classList.add('active');
            downloadFill.style.width = '0%';
            let downloadProgress = 0;
            const downloadInterval = setInterval(() => {
                downloadProgress = Math.min(downloadProgress + 10, 100);
                downloadFill.style.width = `${downloadProgress}%`;
            }, 200);
            try {
                const response = await fetch('/modify', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ pageOrder, pagesToDelete })
                });
                clearInterval(downloadInterval);
                downloadFill.style.width = '100%';
                if (!response.ok) {
                    const error = await response.json();
                    console.error('Download error:', error);
                    alert('Error generating PDF: ' + error.error);
                    downloadWaitbar.classList.add('hidden');
                    downloadFill.classList.remove('active');
                    downloadStatus.classList.add('hidden');
                    return;
                }
                const blob = await response.blob();
                const url = window.URL.createObjectURL(blob);
                const link = document.createElement('a');
                link.href = url;
                const originalName = originalFile ? originalFile.name.replace(/\.pdf$/i, '') : 'modified';
                link.download = `${originalName}_modified.pdf`;
                document.body.appendChild(link);
                link.click();
                document.body.removeChild(link);
                console.log(`Download initiated: ${link.download}`);
                downloadWaitbar.classList.add('hidden');
                downloadFill.classList.remove('active');
                downloadStatus.classList.add('hidden');
            } catch (error) {
                console.error('Download fetch error:', error);
                alert('Error generating PDF: ' + error.message);
                clearInterval(downloadInterval);
                downloadWaitbar.classList.add('hidden');
                downloadFill.classList.remove('active');
                downloadStatus.classList.add('hidden');
            }
        });

        zoomSlider.addEventListener('input', () => {
            zoomLevel = parseInt(zoomSlider.value);
            renderPages(previews.length);
        });

        function renderPages(totalPages) {
            console.time('renderPages');
            console.log(`Starting renderPages: totalPages=${totalPages}, previews.length=${previews.length}, pageOrder=${JSON.stringify(pageOrder)}`);
            const grid = document.getElementById('page-grid');
            const pageHeight = (350 * zoomLevel / 100) + 16;
            const maxPagesPerColumn = Math.floor(window.innerHeight / pageHeight);
            const visiblePages = pageOrder.filter(idx => !pagesToDelete.includes(idx) && previews[idx]).length;
            const columns = Math.max(1, Math.ceil(visiblePages / maxPagesPerColumn));
            grid.style.gridTemplateColumns = `repeat(${columns}, ${250 * zoomLevel / 100}px)`;
            grid.style.setProperty('--zoom', zoomLevel / 100);

            // Show processing waitbar immediately
            requestAnimationFrame(() => {
                uploadWaitbar.classList.add('hidden');
                processingWaitbar.classList.remove('hidden');
                downloadWaitbar.classList.add('hidden');
                uploadStatus.classList.add('hidden');
                processingStatus.classList.remove('hidden');
                downloadStatus.classList.add('hidden');
                processingFill.classList.add('active');
                processingFill.style.width = '0%';
                processingStatus.textContent = `Processing page 0/${visiblePages}...`;
                // Force repaint
                processingWaitbar.offsetHeight;
                console.log(`Processing waitbar shown: visiblePages=${visiblePages}, style.display=${processingWaitbar.style.display}`);
            });

            const pagesToRender = pageOrder.filter(idx => !pagesToDelete.includes(idx) && previews[idx]).length;
            if (pagesToRender === 0) {
                console.log('No pages to render, hiding processing waitbar');
                requestAnimationFrame(() => {
                    processingFill.style.width = '100%';
                    setTimeout(() => {
                        processingWaitbar.classList.add('hidden');
                        processingFill.classList.remove('active');
                        processingStatus.classList.add('hidden');
                        console.timeEnd('renderPages');
                    }, 500);
                });
                grid.innerHTML = '';
                return;
            }

            let loadedImages = 0;
            const progressPerPage = 100 / pagesToRender;
            grid.innerHTML = '';

            function updateProgress() {
                loadedImages++;
                const renderProgress = Math.min(loadedImages * progressPerPage, 100);
                processingFill.style.width = `${renderProgress}%`;
                processingStatus.textContent = `Processing page ${loadedImages}/${pagesToRender}...`;
                console.log(`Progress updated: ${loadedImages}/${pagesToRender}, ${renderProgress}%`);
                if (loadedImages >= pagesToRender) {
                    requestAnimationFrame(() => {
                        const delay = pagesToRender <= 2 ? 500 : 0;
                        setTimeout(() => {
                            processingWaitbar.classList.add('hidden');
                            processingFill.classList.remove('active');
                            processingStatus.classList.add('hidden');
                            console.log(`Processing complete: ${loadedImages}/${pagesToRender} images loaded`);
                            console.timeEnd('renderPages');
                        }, delay);
                    });
                }
            }

            // Preload images
            const imageElements = [];
            pageOrder.forEach((idx, i) => {
                if (!pagesToDelete.includes(idx) && previews[idx]) {
                    console.log(`Creating image for page ${idx + 1}, base64 length: ${previews[idx].length || 'N/A'}`);
                    const img = new Image();
                    img.src = `data:image/png;base64,${previews[idx]}`;
                    img.alt = `Page ${idx + 1}`;
                    img.onload = () => {
                        console.log(`Image loaded: Page ${idx + 1}, ${loadedImages + 1}/${pagesToRender}`);
                        requestAnimationFrame(updateProgress);
                    };
                    img.onerror = () => {
                        console.error(`Failed to load image for page ${idx + 1}`);
                        requestAnimationFrame(updateProgress);
                    };
                    imageElements.push({ idx, img });
                }
            });

            // Append images incrementally
            let appendIndex = 0;
            function appendNextImage() {
                if (appendIndex >= imageElements.length) {
                    // Initialize Sortable after all images are appended
                    new Sortable(grid, {
                        animation: 150,
                        swap: true,
                        onEnd: (evt) => {
                            const oldIndex = parseInt(evt.item.dataset.index);
                            const newIndex = evt.to.children[evt.newIndex].dataset.index
                                ? parseInt(evt.to.children[evt.newIndex].dataset.index)
                                : parseInt(evt.item.dataset.index);
                            if (oldIndex === newIndex) return;
                            console.log(`Reordering: dragged page=${oldIndex + 1}, target page=${newIndex + 1}`);
                            const oldIdx = pageOrder.indexOf(oldIndex);
                            const newIdx = pageOrder.indexOf(newIndex);
                            if (oldIdx === -1 || newIdx === -1) return;
                            [pageOrder[oldIdx], pageOrder[newIdx]] = [pageOrder[newIdx], pageOrder[oldIdx]];
                            console.log('Updated pageOrder:', pageOrder);
                            renderPages(previews.length);
                            updateDebugState();
                        }
                    });

                    document.querySelectorAll('.delete-checkbox').forEach(checkbox => {
                        checkbox.addEventListener('change', (e) => {
                            const idx = parseInt(e.target.dataset.index);
                            console.log(`Delete checkbox clicked: idx=${idx}`);
                            if (e.target.checked) {
                                const pageItem = checkbox.closest('.page-item');
                                pageItem.classList.add('deleting');
                                setTimeout(() => {
                                    pagesToDelete.push(idx);
                                    console.log(`Adding idx to pagesToDelete: ${idx}`);
                                    console.log('pagesToDelete after update:', pagesToDelete);
                                    renderPages(previews.length);
                                    updateDebugState();
                                }, 300);
                            } else {
                                pagesToDelete = pagesToDelete.filter(i => i !== idx);
                                console.log(`Removing idx from pagesToDelete: ${idx}`);
                                console.log('pagesToDelete after update:', pagesToDelete);
                                renderPages(previews.length);
                                updateDebugState();
                            }
                        });
                    });
                    return;
                }

                const { idx, img } = imageElements[appendIndex];
                const div = document.createElement('div');
                div.className = 'page-item';
                div.dataset.index = idx;
                div.innerHTML = `
                    <span class="page-number">${idx + 1}</span>
                    <label class="delete-toggle">
                        <input type="checkbox" class="delete-checkbox" data-index="${idx}">
                        <span class="toggle-slider"></span>
                    </label>
                `;
                div.insertBefore(img, div.firstChild);
                grid.appendChild(div);
                console.log(`Appended page ${idx + 1} to DOM`);
                appendIndex++;
                setTimeout(appendNextImage, 0); // Yield to browser
            }

            requestAnimationFrame(() => {
                appendNextImage();
            });
        }
    </script>
</body>
</html>